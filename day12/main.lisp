(ql:quickload '(:priority-queue))
(use-package :pqueue)

(defun get-nums ()
  (with-open-file (stream "input")
    (let* ((lines
	     (loop :for line = (read-line stream nil)
		   :while line
		   :collect line)))
      (make-array (list (length lines) (length (car lines)) ) :initial-contents lines))))

(defun part-1 ()
  (let* ((map (get-nums))
	 (dims (array-dimensions map))
	 (visited (make-hash-table :test 'equal))
	 (start nil)
	 (end nil)
	 (frontier (make-pqueue '<)))
    (loop :for i from 0 below (car dims)
	  :do (loop :for j from 0 below (cadr dims)
		    :if (char= (aref map i j) #\S)
		      :do (progn (setf start (cons i j))
				 (setf (aref map i j) #\a))
		    :if (char= (aref map i j) #\E)
		      :do (progn (setf end (cons i j))
				 (setf (aref map i j) #\z))))
    (labels ((neighbors (n)
	       (destructuring-bind (x . y) n
		 (remove-if (lambda (n) (or (< (car n) 0)
				       (>= (car n) (car dims))
				       (< (cdr n) 0)
				       (>= (cdr n) (cadr dims))
				       (> (char-code (aref map (car n) (cdr n)))
					  (1+ (char-code (aref map x y))))))
			    (list (cons x (1+ y)) (cons x (1- y))
				  (cons (1+ x) y) (cons (1- x) y))))))
      (setf (gethash start visited) 0)
      (pqueue-push start 0 frontier)
      (loop :named outer
	    :while (not (pqueue-empty-p frontier))
	    :do (multiple-value-bind (nd dist) (pqueue-pop frontier)
		  (when (equal nd end)
		    (return-from outer dist))
		  (loop :for n in (neighbors nd)
			:do (let ((ndist (1+ dist)))
			      (if (gethash n visited)
				  (when (< ndist (gethash n visited))
				    (progn
				      (pqueue-push n ndist frontier)
				      (setf (gethash n visited) ndist)))
				  (progn
				    (pqueue-push n ndist frontier)
				    (setf (gethash n visited) ndist))))))))))

(defun part-2 ()
  (let* ((map (get-nums))
	 (dims (array-dimensions map))
	 (visited (make-hash-table :test 'equal))
	 (end nil)
	 (frontier (make-pqueue '<)))
    (loop :for i from 0 below (car dims)
	  :do (loop :for j from 0 below (cadr dims)
		    :if (char= (aref map i j) #\S)
		      :do (setf (aref map i j) #\a)
		    :if (char= (aref map i j) #\E)
		      :do (progn (setf end (cons i j))
				 (setf (aref map i j) #\z))))
    (labels ((neighbors (n)
	       (destructuring-bind (x . y) n
		 (remove-if (lambda (n) (or (< (car n) 0)
				       (>= (car n) (car dims))
				       (< (cdr n) 0)
				       (>= (cdr n) (cadr dims))
				       (> (char-code (aref map (car n) (cdr n)))
					  (1+ (char-code (aref map x y))))))
			    (list (cons x (1+ y)) (cons x (1- y))
				  (cons (1+ x) y) (cons (1- x) y))))))
      (loop :for i from 0 below (car dims)
	    :do (loop :for j from 0 below (cadr dims)
		      :if (char= (aref map i j) #\a)
			:do (progn (setf (gethash (cons i j) visited) 0)
				   (pqueue-push (cons i j) 0 frontier))))
      (loop :named outer
	    :while (not (pqueue-empty-p frontier))
	    :do (multiple-value-bind (nd dist) (pqueue-pop frontier)
		  (when (equal nd end)
		    (return-from outer dist))
		  (loop :for n in (neighbors nd)
			:do (let ((ndist (1+ dist)))
			      (if (gethash n visited)
				  (when (< ndist (gethash n visited))
				    (progn
				      (pqueue-push n ndist frontier)
				      (setf (gethash n visited) ndist)))
				  (progn
				    (pqueue-push n ndist frontier)
				    (setf (gethash n visited) ndist))))))))))
